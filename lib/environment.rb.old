require_relative('helpers')
require 'optparse'
require 'sqlite3'  # gem install sqlite3
require 'yaml'
class Environment

  # Accessors
  # External classes wishing to use the environment accessors can include this module
  module Accessors
    def option(o)        get_value(o,:options)      end
    def path(p)          get_value(p,:paths)        end
    def setting(s)       get_value(s,:settings)     end
    def export_filters() get_value(:export_filters) end
    def db()             get_value(:db)             end
    def query(q)         get_value(q,:queries)      end

    def get_value(name,group=nil)
p "get_value #{name} #{group}"
p self
      value = nil

      if group
        if gvar = instance_variable_get('@'+group.to_s)
          value = gvar[name.to_sym]
        end
      else
        value = instance_variable_get('@'+name.to_s)
      end

      value = self.class.get_value(name,group) if value.nil? and self.class.respond_to?(:get_value)
        
      return value
    end

    def posts
      log "Running posts query\n#{query(:posts)}"
      db.execute(query(:posts)) { |p| yield p }
    end

  end # of module Accessors

  class << self

    include Helpers
  
    include Accessors
  
  protected
  
    # Private accessors
    def options
      @options
    end
    def paths
      @paths
    end
    def settings
      @settings
    end
  
    def load_environment
  
      return if defined?(@options) # only parse options once 
  
      puts "parsing options..."
  
      @options = {}
  
      optparse = OptionParser.new do |opts|
       opts.banner = 'GhostBuster: Export and publish Ghost blog as static pages.'
  
        opts.on("--help", "show helpful documentation") do |v|
          puts File.read("#{File.dirname(__FILE__)}/../doc/HELP")
          exit 0
        end
      
        opts.on("--license", "show the MIT License") do |v|
          puts File.read("#{File.dirname(__FILE__)}/../LICENSE")
          exit 0
        end
      
        opts.on("-v", "--verbose", "Enable verbose message output") do |v|
          verbose_on
        end
      
        @options[:env] = 'development'
        opts.on("-e", "--environment ENV", "Environment to copy from") do |e|
         @options[:env] = e
        end
      
        opts.on("--with-tags TAGS", "Include only posts with these tags (comma-separated)") do |d|
          @options[:with_tags] = d
        end
      
        opts.on("--without-tags TAGS", "Include only posts without these tags (comma-separated)") do
       |d|
          @options[:without_tags] = d
        end
      
        opts.on("-p", "--published", "Only published content") do |v|
         @options[:published] = true
        end
      
        opts.on("-u", "--url URL", "Absolute URL to use in exported blog") do |u|
         @options[:url] = u
        end

        @export_filters = []
        opts.on("-f", "--export-filter FILTERS", "Export filters to use (comma-separated)") do |f|
          @options[:export_filters] = f
        end
      
#        @options[:formats] = []
#        opts.on("--html", "Extract html") do |f|
#         @options[:formats] << :html
#        end
#        opts.on("--html_basic", "Extract html (basic)") do |f|
#         @options[:formats] << :html_basic
#        end
#        opts.on("--markdown", "Extract Markdown") do |f|
#         @options[:formats] << :markdown
#        end
#        opts.on("--yaml", "Extract YAML") do |f|
#         @options[:formats] << :yaml
#        end

        # Look for additional environments
        opts.on("-f", "--environment-file FILE", "Load environments from file") do |f|
          @options[:environment_file] = f
        end
      end
  
      optparse.parse!

      # default format options if not explicitly given as arguments
      #@options[:formats] = [:html, :markdown, :yaml] if @options[:formats].empty?
  
      # Positional arguments
      if ARGV.empty?
        puts optparse
        exit 1
      end
  
      @paths = {source: ARGV[0].dup}
      if File.basename(@paths[:source]) == 'content'
        @paths[:root] = File.dirname(@paths[:source])
      else
        @paths[:root] = @paths[:source]
        @paths[:source] = @paths[:root] + '/content'
      end
      @paths[:destination] = ARGV.count >1 ? ARGV[1] : @paths[:source]
      @paths[:config] = @paths[:root] + '/config.js'
      @paths[:database] = @paths[:source] + '/data/ghost-dev.db'
  
      # Check paths are valid
      @paths.each do |name,path|
        do_or_die(File.exists?(path), "#{name} path '#{path}' is good",
                                      "#{name} path #{path} not found")
      end
  
      # Load configuration file
      do_or_die(config = File.read(@paths[:config]),"read config ok","read config failed")
      config.gsub!(/^\s*?\/\/.*?\n/m,'') # remove comments from config
  
      # Get database file
      match_dbfile = config.match(/#{options[:env]}:\s*{.*?database:\s*{.*?connection:\s*{.*?filename:.*?([\w-]*?\.db)/m)
      dbfile = match_dbfile.nil? ? abort("unable to find database file name for '#{options[:env]}' environment in configuration file") : match_dbfile[1]
  
       @paths[:database] = @paths[:source] + '/data/' + dbfile
  
      # Open database
      dbfile = @paths[:database]
      do_or_die(File.exists?(dbfile),'database found',"Cannot find database file #{dbfile}")
      do_or_die(@db = SQLite3::Database.new(dbfile),'database opened',
                                                    "Could not initialise database #{dbfile}")
      @db.results_as_hash = true
  
      # Load settings from database
      settings = %w[title description logo cover activeTheme]
      query = "select key,value from settings where key in (#{settings.map{|s|"'#{s}'"}.join(',')})"
      @settings = {}
      do_or_die(@db.execute(query).each{|s| @settings.update s[0].to_sym => s[1]},
            'read settings','unable to read settings')
      @settings.each { |k,v| log "setting(#{k}) = #{v}" }
  
      # Set the URL that will be used as the root on exported blogs
      if @options.include?(:url)
        @settings[:url] = @options[:url]
      else
        # Get site URL from config file and put it into settings array
        match_url = config.match(/#{options[:env]}:\s*{.*?url:\s*'(.*?)'/m)
        url = match_url.nil? ? abort("unable to find url for #{options[:env]} environment") : match_url[1]
        @settings[:url] = url
      end
  
      # Build posts query
      @queries = {}
      @queries[:posts] = 'SELECT posts.*, users.name as author_name from posts' \
                     << ' INNER JOIN users ON posts.author_id = users.id'
  
      whand = ' WHERE' # will change to 'AND' for subsequent clauses
      unless option(:with_tags).nil?   
        @queries[:posts] << whand << ' EXISTS (' \
                         <<   'SELECT 1 FROM posts_tags' \
                         <<   ' INNER JOIN tags ON tags.id = posts_tags.tag_id' \
                         <<   ' WHERE posts_tags.post_id = posts.id' \
                         <<   ' AND tags.name IN (' \
                         <<   option(:with_tags).split(',').map {|t| "'#{t}'" }.join(',') \
                         <<   '))'             
        whand = ' AND'
      end
  
      unless option(:without_tags).nil?
        @queries[:posts] << whand << ' NOT EXISTS (SELECT 1 FROM posts_tags' \
                         <<   ' INNER JOIN tags ON tags.id = posts_tags.tag_id' \
                         <<   ' WHERE posts_tags.post_id = posts.id' \
                         <<   ' AND tags.name IN (' \
                         <<   option(:without_tags).split(',').map {|t| "'#{t}'" }.join(',') \
                         <<   '))'                
        whand = ' AND'
      end
  
      @queries[:posts] << whand << " posts.status == 'published'" if option(:published) 
      @queries[:posts] << ' ORDER BY posts.published_at DESC'
  #    @queries[:posts] << " LIMIT 1" # Debugging limit
  
#      # Load modules for output filters
#      @export_filters = []
#      @options[:formats].each do |f|
#        f = f.to_s
#        log "Loading #{f} output filter"
#        require_relative 'export_filters/export_'+f
#        @export_filters << Object.const_get('ExportFilter_'+f).new(self)
#      end
  
       # Add export filters (which auto load themselves)
       options[:export_filters].split(',').each { |f| add_export_filter(f,self) }

       # Load additional environments
       if @options[:environment_file]
          YAML.load_file(@options[:environment_file]).each { |e| Environment.new(e[1]) }
       end
    end

  public

    # Add an export filter with the given environment
#    @export_filters = []
    def add_export_filter(filter,env)
      log "Loading #{filter} export filter with environment #{env}"
      begin
        require_relative 'export_filters/export_'+filter
      rescue LoadError
        abort("Failed to load export filter '#{filter}'")
      end
      @export_filters << Object.const_get('ExportFilter_'+filter).new(env)
    end
  
  end # of class << self

  include Accessors

  def initialize(e)

    puts "big new e"
    @options = {}
    p e

    e.each { |k,v| @options[k.to_sym] = v }
    %w(filter filters export-filters).each do |f|
      if e.include?(f)
        e[f].split(' ').each { |f| self.class.add_export_filter(f,self) }
        e.delete(f)
      end
    end
  end

  # Load the environment
  self.load_environment

end
